# 顺序表

在计算机中的内存,不论其硬件实现如何,最终都是以一个有序序列提供给我们的.在C语言中的指针变量的值就是计算机中内存地址的编号.从0x0000 0000开始编址一直到0xFFFF FFFF(这里为了简化表示,缩小了地址范围.)

所以,编程中,最简单,最直接的数据结构就是顺序表,即数组实现的表.数组就用来表示一连串的数据.并且在通常的编程语言实践中,将数组限制为只能存储一种数据类型,来简化各种操作.

*思考题1 : 顺序表能否容纳不同的数据类型呢?(参考答案见文章底部)*


*思考题2 : 为什么大多数语言都将顺数组的数据限制为同一类型?*

## 顺序表操作的时间复杂度
* PrintList()
	$O(N)$
* MakeEmpty()
	$O(1)$
* Find(T ele)
	$O(N)$
* Insert(T ele, int index)
	$O(N)$
* Delete(T ele)
	$O(N)$
* FindKth(int index)
	$O(1)$

**关于为什么时间复杂度的原因这里就不再解释了,如果对时间复杂度不太了解,可以倒回去看看符号定义一章.**


## 顺序表的特点
* 在知道了元素位置的时候,读写特别快
* 查找元素需要遍历整个表
* 插入,删除元素需要移动操作位置后面的所有元素.

**由于删除和插入的时间复杂度如此之高, 一般不使用顺序表来实现表这种结构.**

# 思考题参考答案:
1. 顺序表能否容纳不同的数据类型呢?
答: 顺序表能够容纳不同的数据类型, 因为顺序表本质上就是一连串的内存地址,内存保存仅仅是bit信息.所以说,顺序表是能够容纳不同数据类型的.下面是一段示例代码.
```c
// code/types.c
#include <stdio.h>
#include <stdlib.h>


int main(){
	void *array = malloc((sizeof(int) + sizeof(float) + sizeof(char))*2);
	int off1 = sizeof(int), off2 = sizeof(float), off3 = sizeof (char);

	int *i = array;
	*i = 10;

	float *f = array + off1 ;
	*f = 5.0;
	char *c = array + off1 + off2 ;
	*c = 'A';

	printf("int = %d, float = %f, char = %c\n", *(int*)array, *(float*)(array+off1), *(char*)(array + off1 + off2));
	return 0;
}
```
**郑重说明: 上面的代码没有实际意义,仅仅作为演示使用**,我没有接触过内存池,不清楚内存池是否有这样的用法.

在上面的代码中,我申请了一块内存(在我机器上,是(4+4+1)*2 = 18个字节的内存.这个内存是连续的地址空间. 我将该内存中的前四个字节用于存放整数,再后面四个字节用来存储浮点数,然后再用一个字节存储一个字符. 最终也输出了赋予的值.

**注 : 该代码仅演示了顺序表具有这个能力,但是强烈不建议这样使用顺序表**,人作为杂食动物,也有吃米田共的能力,但是我想没有人会真的去吃吧/xyx.


*思考题2 : 为什么大多数语言都将顺序表的数据限制为同一类型?*

答 : 顺序表的目的就是用来存储一系列的相同类型的数据. 顺序表的随机访问的能力,实际上使用过地址偏移来实现的. 固定的数据类型的地址偏移基数也是固定的,例如存储double数据类型的顺序表, 其占用的内存基数就是8个字节,因此,我们访问第二个元素,只需要在顺序表首部往后偏移8个字节就能够拿到这个数据的地址.

在思考题1的代码中,也看到了将顺序表用于不同类型是多么的费劲了.
